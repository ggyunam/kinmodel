name: DA_explicit_DA3_two_int_ss
description: |
    Simple model for diacid assembly with explicit consideration of
    linear anhydride intermediates, capped at the trimer (DA3).
    Separate intermediates for EDC consumption and anhydride
    exchange are used.

         DA1 + E ---> I1         (k1)
              I1 ---> DA1 + U    (kih)
              I1 ---> C + U      (kiC)
        I1 + DA1 ---> DA2 + U    (kiL)
        I1 + DA2 ---> DA3 + U    (kiL)
             DA2 <--> DA1 + Ip1  (k2L, km2L)
               C <--> Ip1        (k2C, km2C)
             DA3 <--> DA2 + Ip1  (k2L, km2L)
             DA3 <--> Ip2 + DA1  (k2L, km2L)
             Ip1 ---> DA1        (k3)
             Ip2 ---> DA2        (k3)
         DA2 + E ---> I2         (k1)
              I2 ---> DA2 + U    (kih)
        I2 + DA1 ---> DA3 + U    (kiL)

    Steady-state approximations with K1 = kih/kiL, EM1 = kiC/kiL,
    K2 = k3/km2L, and EM2 = km2C/km2L.
    Orders: k1, K1, EM1, K2, EM2, k2C, k2L; DA1, E, U, DA2, DA3, C.
eq_function: |
    def equations(concs, t, *ks):
        DA1, E, U, DA2, DA3, C = concs
        k1, K1, EM1, K2, EM2, k2C, k2L = ks

        # Return the equations for concs
        return [
            (DA3*k2L + k2L*DA2 - k1*DA1*E
                - (DA1*(DA3*k2L + k2C*C + k2L*DA2))/(EM2 + K2 + DA1 + DA2)
                + (K2*(DA3*k2L + k2C*C + k2L*DA2))/(EM2 + K2 + DA1 + DA2)
                - (k1*DA1**2*E)/(EM1 + K1 + DA1 + DA2)
                - (DA3*k2L*DA1)/(K2 + DA1) + (K1*k1*DA1*E)/(EM1 + K1 + DA1 + DA2)
                - (k1*DA1*DA2*E)/(K1 + DA1)),
            - k1*DA1*E - k1*DA2*E,
            + k1*DA1*E + k1*DA2*E,
            (DA3*k2L - k2L*DA2 - k1*DA2*E
                + (DA1*(DA3*k2L + k2C*C + k2L*DA2))/(EM2 + K2 + DA1 + DA2)
                - (DA2*(DA3*k2L + k2C*C + k2L*DA2))/(EM2 + K2 + DA1 + DA2)
                + (DA3*K2*k2L)/(K2 + DA1) + (k1*DA1**2*E)/(EM1 + K1 + DA1 + DA2)
                + (K1*k1*DA2*E)/(K1 + DA1)
                - (k1*DA1*DA2*E)/(EM1 + K1 + DA1 + DA2)),
            ((DA2*(DA3*k2L + k2C*C + k2L*DA2))/(EM2 + K2 + DA1 + DA2) - 2*DA3*k2L
                + (DA3*k2L*DA1)/(K2 + DA1)
                + (k1*DA1*DA2*E)/(EM1 + K1 + DA1 + DA2)
                + (k1*DA1*DA2*E)/(K1 + DA1)),
            ((EM2*(DA3*k2L + k2C*C + k2L*DA2))/(EM2 + K2 + DA1 + DA2) - k2C*C
                + (EM1*k1*DA1*E)/(EM1 + K1 + DA1 + DA2)),
        ]
k_var: 
    - name: "k1"
      guess: 1
    - name: "K1"
      guess: 40
    - name: "EM1"
      guess: 50
    - name: "K2"
      guess: 45
    - name: "EM2"
      guess: 100
    - name: "k2C"
      guess: 1e-2
    - name: "k2L"
      guess: 2e-2
k_const:
conc0_var:
    - name: "[DA1]0"
      guess: 25
    - name: "[EDC]0"
      guess: 50
conc0_const:
    - name: "[U]0"
      value: 0
    - name: "[DA2]0"
      value: 0
    - name: "[DA3]0"
      value: 0
    - name: "[C]0"
      value: 0
species:
    - name: "DA1"
      plot: bottom
    - name: "EDC"
      plot: top
    - name: "Urea"
      plot: top
    - name: "DA2"
      plot: bottom
    - name: "DA3"
      plot: bottom
    - name: "Cy"
      plot: bottom
integrals:
    - desc: "(k2L*EM2*DA3)/(EM2+K2+DA1+DA2)"
      func: "lambda c, k: ((k[6]*k[4]*c[4]) / (k[4]+k[3]+c[0]+c[3]))"
    - desc: "(k2C*EM2*C)/(EM2+K2+DA1+DA2)"
      func: "lambda c, k: ((k[5]*k[4]*c[5]) / (k[4]+k[3]+c[0]+c[3]))"
    - desc: "(k2L*EM2*DA2)/(EM2+K2+DA1+DA2)"
      func: "lambda c, k: ((k[6]*k[4]*c[3]) / (k[4]+k[3]+c[0]+c[3]))"
    - desc: "k2C*C"
      func: "lambda c, k: k[5]*c[5]"
    - desc: "(EM1*k1*DA1*E)/(EM1+K1+DA1+DA2)"
      func: "lambda c, k: ((k[2]*k[0]*c[0]*c[1]) / (k[2]+k[1]+c[0]+c[3]))"
calcs:
    - desc: "C produced directly from EDC ∫(EM1*k1*DA1*E)/(EM1+K1+DA1+DA2)dt"
      func: "lambda c, t, k, i: i[4]"
    - desc: "C yield directly from EDC ∫(EM1*k1*DA1*E)/(EM1+K1+DA1+DA2)dt/E0"
      func: "lambda c, t, k, i: i[4] / c[1][0]"
    - desc: "Total C hydrolysis ∫(k2C*C)dt"
      func: "lambda c, t, k, i: i[3]"
    - desc: "C produced from DA2 exchange ∫(k2L*EM2*DA2)/(EM2+K2+DA1+DA2)dt"
      func: "lambda c, t, k, i: i[2]"
    - desc: "C produced from DA3 exchange ∫(k2L*EM2*DA3)/(EM2+K2+DA1+DA2)dt"
      func: "lambda c, t, k, i: i[0]"
    - desc: "C produced from C after decomp ∫(k2C*EM2*C)/(EM2+K2+DA1+DA2)dt"
      func: "lambda c, t, k, i: i[1]"
lifetime_concs:
    - 3
    - 4
    - 5
rectime_concs:
    - 0
